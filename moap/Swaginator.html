<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="pragma" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HUD Message (Fit-first, Scroll-last)</title>

  <style>
    /* ============================================================
       TWEAKABLE DEFAULTS (Safe, legible values for MOAP)
       You can override any of these via query params at runtime.
       ------------------------------------------------------------
       Colour scheme: pick one, or keep your own.
    ============================================================ */
    :root{
      /* Winter “Slate & Ice” — high contrast on MOAP */
      --bg:#1c232c;         /* background */
      --fg:#eaf2fb;         /* text colour */
      --accent:#bfe3ff;     /* used by scroll hint */

      /* Typography + spacing defaults
         You can adjust these directly, or via query params:
         min_px, max_px, min_lh, max_lh, min_pad, max_pad, align
      */
      --align:center;       /* left | center | right */

      /* Bounds the fitter will respect */
      --min-font-px:13;     /* absolute floor for readability (12–14 px recommended) */
      --max-font-px:48;     /* ceiling if text is very short */
      --min-line:1.12;      /* tighter bound; 1.08–1.15 is typical min */
      --max-line:1.32;      /* roomier bound; 1.28–1.36 is typical max */
      --min-pad-vmin:0.8;   /* smallest side padding (vmin) before we give up fitting */
      --max-pad-vmin:2.0;   /* preferred padding; try 1.2–2.4 */

      /* Initial “preferred” values the fitter starts from */
      --pref-font-px:32;    /* starting guess; fitter will move toward bounds */
      --pref-line:1.24;
      --pref-pad-vmin:1.6;

      /* Rendering */
      --scrollbar: 10px;    /* visual width of custom scrollbar */
      --fade-height: 16px;  /* height of bottom fade when scroll enabled */
    }

    /* Base reset + colours */
    *{ box-sizing:border-box; }
    html, body {
      margin:0; padding:0; height:100%;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto,
                   'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif;
      overflow:hidden; /* we scroll only the message box if needed */
    }

    /* Full-bleed stage */
    .wrap{ width:100vw; height:100vh; }
    .card{
      width:100vw; height:100vh;
      display:grid; place-items:center;
      background:var(--bg);
    }

    /* The scrollable/fittable message box */
    .msg{
      /* Padding is expressed in vmin so it scales with your banner height */
      --pad: calc(var(--pref-pad-vmin) * 1vmin);
      padding: var(--pad);

      /* These are live-tuned by JS between your min/max bounds */
      --fs: var(--pref-font-px);
      --lh: var(--pref-line);

      font-size: calc(var(--fs) * 1px);
      line-height: var(--lh);
      text-align: var(--align);

      /* Wrapping for nasty long tokens / IDs / URLs */
      white-space: normal;
      word-break: break-word;
      overflow-wrap: anywhere;
      hyphens: auto;

      /* No scroll by default; JS adds .scrollable if it can’t fit */
      overflow-y: hidden;
      max-width: 100%;
      max-height: 100%;

      position: relative; /* for fade + hint */
    }

    /* Subtle bottom fade appears only when scrollable */
    .msg.scrollable::after{
      content:'';
      position:absolute;
      left:0; right:0; bottom:0;
      height: var(--fade-height);
      pointer-events:none;
      background: linear-gradient(to bottom, rgba(28,35,44,0), rgba(28,35,44,.85));
    }

    /* “Scroll” hint — appears only when scrollable */
    .hint{
      position:absolute;
      bottom:4px; right:8px;
      font-size: 11px;
      line-height:1;
      opacity:.8;
      background: rgba(0,0,0,.15);
      padding:4px 6px;
      border-radius:6px;
      display:none;
      user-select:none;
    }
    .msg.scrollable .hint{ display:block; }

    /* Lightweight custom scrollbar (Chromium/WebKit — SL viewer is Chromium-based) */
    .msg.scrollable{
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;               /* Firefox */
      scrollbar-color: var(--accent) transparent;
    }
    .msg.scrollable::-webkit-scrollbar{ width: var(--scrollbar); }
    .msg.scrollable::-webkit-scrollbar-thumb{
      background: linear-gradient(180deg, var(--accent), #8fbfe8);
      border-radius: 8px;
    }
    .msg.scrollable::-webkit-scrollbar-track{
      background: transparent;
    }

    /* Accessibility: reduce motion users don’t need the breathing animation */
    @media (prefers-reduced-motion: reduce){
      .breath{ animation:none !important; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div id="message" class="msg">
        <span id="hint" class="hint">Scroll ▾</span>
      </div>
    </div>
  </div>

  <script>
    /* ============================================================
       RUNTIME CONTROLS (what you can tweak from LSL)
       ------------------------------------------------------------
       Query params you can pass, all optional:

       t        = message text (URL-encoded). Newlines allowed.
       align    = left | center | right               (default: CSS var)
       min_px   = min font size in px                 (default: --min-font-px)
       max_px   = max font size in px                 (default: --max-font-px)
       min_lh   = min line-height (unitless)          (default: --min-line)
       max_lh   = max line-height (unitless)          (default: --max-line)
       min_pad  = min padding in vmin                 (default: --min-pad-vmin)
       max_pad  = max padding in vmin                 (default: --max-pad-vmin)
       pref_px  = preferred font size (px)            (default: --pref-font-px)
       pref_lh  = preferred line-height               (default: --pref-line)
       pref_pad = preferred padding (vmin)            (default: --pref-pad-vmin)

       fit      = strategy (optional):
                  'shrink-then-scroll' (default)  → try shrink within bounds, else scroll
                  'clamp-then-scroll'             → try clamping to N lines first (not used here)
    ============================================================ */

    (function(){
      var QS = new URLSearchParams(location.search);

      function num(x, fallback){ var v = Number(x); return isFinite(v) ? v : fallback; }
      function cssVar(name){
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      }
      function setVar(name, val){ document.documentElement.style.setProperty(name, val); }

      // 1) Read defaults from CSS, allow query param overrides
      var bounds = {
        minPx:  num(QS.get('min_px'),  Number(cssVar('--min-font-px')) ),
        maxPx:  num(QS.get('max_px'),  Number(cssVar('--max-font-px')) ),
        minLH:  num(QS.get('min_lh'),  Number(cssVar('--min-line'))    ),
        maxLH:  num(QS.get('max_lh'),  Number(cssVar('--max-line'))    ),
        minPad: num(QS.get('min_pad'), Number(cssVar('--min-pad-vmin'))),
        maxPad: num(QS.get('max_pad'), Number(cssVar('--max-pad-vmin')))
      };

      var prefs = {
        px:  num(QS.get('pref_px'),  Number(cssVar('--pref-font-px')) ),
        lh:  num(QS.get('pref_lh'),  Number(cssVar('--pref-line'))    ),
        pad: num(QS.get('pref_pad'), Number(cssVar('--pref-pad-vmin')))
      };

      var align = QS.get('align');
      if (align === 'left' || align === 'center' || align === 'right'){
        setVar('--align', align);
      }

      // 2) Apply starting (preferred) values
      setVar('--pref-font-px', prefs.px);
      setVar('--pref-line',    prefs.lh);
      setVar('--pref-pad-vmin',prefs.pad);

      // 3) Message text: escape + convert \n to <br/>
      function escapeHTML(s){
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
      }
      var raw = QS.get('t') || '';
      raw = raw.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      var safeHTML = escapeHTML(raw).replace(/\n/g, '<br/>');

      var msgEl = document.getElementById('message');
      msgEl.innerHTML = safeHTML + msgEl.innerHTML; // keep the hint span inside

      var hintEl = document.getElementById('hint');

      // Helper: does content fit vertically?
      function fits(){
        // Subtract bottom fade so we don't hide the last line when not scrollable
        var fade = parseFloat(getComputedStyle(msgEl).getPropertyValue('--fade-height')) || 0;
        return (msgEl.scrollHeight <= (msgEl.clientHeight + 0.5)) || // tiny tolerance
               (msgEl.scrollHeight - fade <= msgEl.clientHeight + 0.5);
      }

      // Binary search the largest font size in [lo, hi] that fits
      function bestFontSize(lo, hi){
        var best = lo;
        while (hi - lo > 0.5){                     // px precision
          var mid = (lo + hi) / 2;
          setVar('--fs', mid);
          if (fits()){ best = mid; lo = mid; } else { hi = mid; }
        }
        setVar('--fs', best);
        return best;
      }

      // Try fit in this order: font size → line-height → padding
      function fitOrScroll(){
        // Start from prefs (in case of resize) but respect bounds
        setVar('--fs', Math.max(bounds.minPx, Math.min(bounds.maxPx, prefs.px)));
        setVar('--lh', Math.max(bounds.minLH, Math.min(bounds.maxLH, prefs.lh)));
        setVar('--pad', 'calc(' + Math.max(bounds.minPad, Math.min(bounds.maxPad, prefs.pad)) + ' * 1vmin)');

        // 1) Font size search
        bestFontSize(bounds.minPx, bounds.maxPx);

        // 2) If still overflows, tighten line-height (down to minLH in small steps)
        var lh = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--lh')) || prefs.lh;
        if (!fits()){
          var step = 0.02;
          while (lh - step >= bounds.minLH){
            lh = +(lh - step).toFixed(2);
            setVar('--lh', lh);
            if (fits()) break;
          }
        }

        // 3) If still overflows, reduce padding (down to minPad in small steps)
        if (!fits()){
          var pad = Math.max(bounds.minPad, Math.min(bounds.maxPad, prefs.pad));
          var padStep = 0.2; // vmin
          while (pad - padStep >= bounds.minPad){
            pad = +(pad - padStep).toFixed(2);
            setVar('--pad', 'calc(' + pad + ' * 1vmin)');
            if (fits()) break;
          }
        }

        // 4) If it *still* overflows → enable scrolling + hint
        if (!fits()){
          msgEl.classList.add('scrollable');
          hintEl.style.display = 'block';
        }else{
          msgEl.classList.remove('scrollable');
          hintEl.style.display = 'none';
          // optional polish: inflate font slightly if lots of spare room
          // (commented to keep behaviour predictable)
          // bestFontSize(Math.max(bounds.minPx, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fs'))), bounds.maxPx);
        }
      }

      // Debounced resize handler (MOAP can change viewport as prim resizes)
      var to = null;
      function onResize(){
        clearTimeout(to);
        to = setTimeout(fitOrScroll, 50);
      }
      window.addEventListener('resize', onResize);

      // Initial fit
      fitOrScroll();
    })();
  </script>
</body>
</html>
